#include <iostream>
#include <stdlib.h>
#include <time.h>
#include "../include/algorithm.h"

#define MAX_VAL 100000

bool first_turn = true;

using namespace std;


void choose_cell(Board board, int& row, int& col, Player *player);

int evaluate(Board board, char pre_color, char next_color);


bool in_board(int i, int j);
bool win(Board board, char pre_color, char next_color);



//為什麼第一步會下在0,0?
//因為在evaluate 0,0 的時候 發現贏了(第一步只有自己)

//為什麼會一直下廣呢?
//因為evaluation中 多一個cell = 多一個 value來源










/******************************************************
 * In your algorithm, you can just use the the funcitons
 * listed by TA to get the board information.(functions
 * 1. ~ 4. are listed in next block)
 *
 * The STL library functions is not allowed to use.
******************************************************/

/*************************************************************************
 * 1. int board.get_orbs_num(int row_index, int col_index)
 * 2. int board.get_capacity(int row_index, int col_index)
 * 3. char board.get_cell_color(int row_index, int col_index)
 * 4. void board.print_current_board(int row_index, int col_index, int round)
 *
 * 1. The function that return the number of orbs in cell(row, col)
 * 2. The function that return the orb capacity of the cell(row, col)
 * 3. The function that return the color fo the cell(row, col)
 * 4. The function that print out the current board statement
*************************************************************************/


void algorithm_A(Board board, Player player, int index[]) {

	//////your algorithm design///////////


	// 主要是回傳(但不會回傳 是改值)  :  index[0] = row , index[1] = col 寫下自己的最終決定
	// board 跟 player 只是你查閱的對象 不能更動

	int row, col;
	char color = player.get_color();
	
	char ene_color;
	if (color == 'r') ene_color = 'b';
	else ene_color = 'r';

	Player * tmp_player = new Player(player.get_color());

	choose_cell(board, row, col, tmp_player);
	

	index[0] = row, index[1] = col;
}


void choose_cell(Board board, int& row, int& col, Player *player) {

	Board tmp_board = board;
	char color = player->get_color();

	char ene_color;
	if (color == 'r') ene_color = 'b';
	else ene_color = 'r';

	int total_val[5][6];
	int max_val = -MAX_VAL;
	int max_val_row;
	int max_val_col;

	if (first_turn) {
		row = 2;
		col = 2;
		first_turn = false;
		return;
	}

	for (int i = 0; i < ROW; i++) {
		for (int j = 0; j < COL; j++) {

			if (board.get_cell_color(i, j) == color || board.get_cell_color(i, j) == 'w') {

				tmp_board.place_orb(i, j, player);

				total_val[i][j] = evaluate(tmp_board, color, ene_color);


				// 如果下了然後贏了
				if (total_val[i][j] == MAX_VAL){
					row = i;
					col = j;
					return;
				}   
				
				//cout << total_val[i][j] << endl;
				
				if (total_val[i][j] > max_val) {

					max_val = total_val[i][j];
					max_val_row = i;
					max_val_col = j;

				}

				tmp_board = board;
			}
			else continue;

		}
	}

	row = max_val_row;
	col = max_val_col;

}



// 要解決: 如果下的廣一點 分數就會比較多 的問題

// pre_color代表之前下的是誰 ; now_color代表下個下的是誰
// evaluate 判斷的是 pre_color 下完後 , next_color 下之前 的 value
// 可藉此判斷 pre_color 下的這步所造成的   """ 對於對方來說的整盤value """  好不好
int evaluate(Board board, char pre_color, char next_color) {

	// 贏了就下
	if (win(board, pre_color, next_color)) return MAX_VAL;

	int cell_val[ROW][COL];
	int total_val = 0;


	for (int i = 0; i < ROW; i++) {
		for (int j = 0; j < COL; j++) {
			cell_val[i][j] = 0;
			int cur_orb_num = board.get_orbs_num(i, j);
			int cur_cap = board.get_capacity(i, j);

			if (board.get_cell_color(i,j) == 'w') continue;		//如果空白就 = 0
			
			//自己的cell
			if (board.get_cell_color(i, j) == pre_color) {
				//************************basic value***************************

				//爆炸範圍
				cell_val[i][j] += cur_cap;
				cell_val[i][j] += cur_orb_num;

				//還差多少orb可爆炸
				cell_val[i][j] += 10 * cur_orb_num/cur_cap;

				//************************bomb value***************************

				//大於 or 小於 隔壁的orb數量 (可疊加)
				//上 左上 左 左下 下 右下 右 右上

				//如果小於隔壁的 那val就 - 自己的orb_num(因為會被吃掉)
				//越多比自己大的隔壁cell 就 - 越多(但越多cell 就減的越少)

				//如果必隔壁多 就 +=對方的orb_num

				if (in_board(i - 1, j)) {
					if (board.get_cell_color(i - 1, j) == next_color) {
						if (board.get_orbs_num(i - 1, j) >= cur_orb_num) {
							cell_val[i][j] -= cur_orb_num;
							cell_val[i][j] -= cur_cap;
						}
						else {
							cell_val[i][j] += board.get_orbs_num(i - 1, j);
							cell_val[i][j] += board.get_capacity(i - 1, j);
						}

					}
				}

				if (in_board(i - 1, j - 1)) {
					if (board.get_cell_color(i - 1, j - 1) == next_color) {
						if (board.get_orbs_num(i - 1, j - 1) >= cur_orb_num) {
							cell_val[i][j] -= cur_orb_num;
							cell_val[i][j] -= cur_cap;
						}
						else {
							cell_val[i][j] += board.get_orbs_num(i - 1, j - 1);
							cell_val[i][j] += board.get_capacity(i - 1, j - 1);
						}
					}
				}

				if (in_board(i, j - 1)) {
					if (board.get_cell_color(i, j - 1) == next_color) {
						if (board.get_orbs_num(i, j - 1) >= cur_orb_num) {
							cell_val[i][j] -= cur_orb_num;
							cell_val[i][j] -= cur_cap;
						}
						else {
							cell_val[i][j] += board.get_orbs_num(i, j - 1);
							cell_val[i][j] += board.get_capacity(i, j - 1);
						}
					}
				}

				if (in_board(i + 1, j - 1)) {
					if (board.get_cell_color(i + 1, j - 1) == next_color) {
						if (board.get_orbs_num(i + 1, j - 1) >= cur_orb_num) {
							cell_val[i][j] -= cur_orb_num;
							cell_val[i][j] -= cur_cap;
						}
						else {
							cell_val[i][j] += board.get_orbs_num(i + 1, j - 1);
							cell_val[i][j] += board.get_capacity(i + 1, j - 1);
						}
					}
				}

				if (in_board(i + 1, j)) {
					if (board.get_cell_color(i + 1, j) == next_color) {
						if (board.get_orbs_num(i + 1, j) >= cur_orb_num) {
							cell_val[i][j] -= cur_orb_num;
							cell_val[i][j] -= cur_cap;
						}
						else {
							cell_val[i][j] += board.get_orbs_num(i + 1, j);
							cell_val[i][j] += board.get_capacity(i + 1, j);
						}
					}
				}

				if (in_board(i + 1, j + 1)) {
					if (board.get_cell_color(i + 1, j + 1) == next_color) {
						if (board.get_orbs_num(i + 1, j + 1) >= cur_orb_num) {
							cell_val[i][j] -= cur_orb_num;
							cell_val[i][j] -= cur_cap;
						}
						else {
							cell_val[i][j] += board.get_orbs_num(i + 1, j + 1);
							cell_val[i][j] += board.get_capacity(i + 1, j + 1);
						}
					}
				}

				if (in_board(i, j + 1)) {
					if (board.get_cell_color(i, j + 1) == next_color) {
						if (board.get_orbs_num(i, j + 1) >= cur_orb_num) {
							cell_val[i][j] -= cur_orb_num;
							cell_val[i][j] -= cur_cap;
						}
						else {
							cell_val[i][j] += board.get_orbs_num(i, j + 1);
							cell_val[i][j] += board.get_capacity(i, j + 1);
						}
					}
				}

				if (in_board(i - 1, j + 1)) {
					if (board.get_cell_color(i - 1, j + 1) == next_color) {
						if (board.get_orbs_num(i - 1, j + 1) >= cur_orb_num) {
							cell_val[i][j] -= cur_orb_num;
							cell_val[i][j] -= cur_cap;
						}
						else {
							cell_val[i][j] += board.get_orbs_num(i - 1, j + 1);
							cell_val[i][j] += board.get_capacity(i - 1, j + 1);
						}
					}
				}


				//************************critical value***************************

				//如果變成可爆 value += 10

				if (board.get_capacity(i, j) - cur_orb_num == 1) cell_val[i][j] += 10;

			}

			//ene的cell
			if (board.get_cell_color(i, j) == next_color) {


				//************************ene bomb negative value***************************











				
			}
			

			total_val += cell_val[i][j];
		}
	}

	return total_val;

}

bool win(Board board, char pre_color, char next_color){
	bool win = true;

	for (int i = 0; i < ROW; i++) {
		for (int j = 0; j < COL; j++) {
			if (board.get_cell_color(i, j) == pre_color || board.get_cell_color(i, j) == 'w') continue;
			else {
				win = false;
				break;
			}
		}
		if (!win) break;
	}
	return win;
}

bool in_board(int i, int j) {
	if (i > ROW || i < 0 || j > COL || j < 0)
		return false;
	else return true;
}


//bool first_turn(Board board) {
//	for (int i = 0; i < ROW; i++) {
//		for (int j = 0; j < COL; j++) {
//			if (board.get_cell_color()) != 'w';
//		}
//	}
//}
