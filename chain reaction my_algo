#include <iostream>
#include <stdlib.h>
#include <time.h>
#include "../include/algorithm.h"

#define MAX_VAL 100000
#define MAX_TREE_HEIGHT 2

#define CRITICAL_VALUE 500;
#define ENEMY_CRITICAL_NEAR_VALUE -100;

bool first_turn(Board board);

using namespace std;

// true = max, false = min
int choose_cell(Board board, int& row, int& col, Player *player, bool m, int step);

int evaluate(Board board, char pre_color, char next_color);

int Cell_Val(Board board, int i, int j, char pre_color, char next_color);


int ratio_of_cell(Board board, int i, int j);
bool critical(Board board, int i, int j);
bool in_board(int i, int j);
bool win(Board board, char pre_color, char next_color);



//為什麼第一步會下在0,0?
//因為在evaluate 0,0 的時候 發現贏了(第一步只有自己)

//為什麼會一直下廣呢?
//因為evaluation中 多一個cell = 多一個 value來源










/******************************************************
 * In your algorithm, you can just use the the funcitons
 * listed by TA to get the board information.(functions
 * 1. ~ 4. are listed in next block)
 *
 * The STL library functions is not allowed to use.
******************************************************/

/*************************************************************************
 * 1. int board.get_orbs_num(int row_index, int col_index)
 * 2. int board.get_capacity(int row_index, int col_index)
 * 3. char board.get_cell_color(int row_index, int col_index)
 * 4. void board.print_current_board(int row_index, int col_index, int round)
 *
 * 1. The function that return the number of orbs in cell(row, col)
 * 2. The function that return the orb capacity of the cell(row, col)
 * 3. The function that return the color fo the cell(row, col)
 * 4. The function that print out the current board statement
*************************************************************************/


void algorithm_A(Board board, Player player, int index[]) {

	//////your algorithm design///////////


	// 主要是回傳(但不會回傳 是改值)  :  index[0] = row , index[1] = col 寫下自己的最終決定
	// board 跟 player 只是你查閱的對象 不能更動

	int row, col;
	char color = player.get_color();
	
	char ene_color;
	if (color == 'r') ene_color = 'b';
	else ene_color = 'r';

	Player * tmp_player = new Player(player.get_color());

	choose_cell(board, row, col, tmp_player, true, 0);
	

	index[0] = row, index[1] = col;
}


int choose_cell(Board board, int& row, int& col, Player *player, bool m, int step) {

	Board tmp_board;
	char color = player->get_color();

	char ene_color;

	// max pre = my ; next = ene;
	if (m) {
		if (color == 'r') ene_color = 'b';
		else ene_color = 'r';
	}
	else {
		if (color == 'r') {
			color = 'b';
			ene_color = 'r';
		}
		else {
			ene_color = 'b';
			color = 'r';
		}
	}


	int total_val[5][6];
	int fin_val;
	if(m) fin_val = -MAX_VAL - 1;
	else fin_val = MAX_VAL + 1;
	int fin_val_row;
	int fin_val_col;
	int tmp_row;
	int tmp_col;

	if (player->get_color() == 'r' && m) {
		if (first_turn(board)) {
			row = 2;
			col = 2;
			return 0;
		}
	}
	for (int i = 0; i < ROW; i++) {
		for (int j = 0; j < COL; j++) {

			tmp_board = board;
			
			if (board.get_cell_color(i, j) == color || board.get_cell_color(i, j) == 'w') {

				if (m)
					tmp_board.place_orb(i, j, player);
				else {
					Player * ene_player = new Player(color);
					tmp_board.place_orb(i, j, ene_player);
				}

				// 如果下了然後贏了
				if (win(board, color, ene_color)) {
					total_val[i][j] = MAX_VAL;
				}
				else {
					if (step >= MAX_TREE_HEIGHT)
						if(m)
							total_val[i][j] = evaluate(tmp_board, color, ene_color);
						else
							total_val[i][j] = -evaluate(tmp_board, color, ene_color);
					else
							total_val[i][j] = choose_cell(tmp_board, tmp_row, tmp_col, player, !m, step + 1);
				}

				if (m) {
					if (total_val[i][j] > fin_val) {

						fin_val = total_val[i][j];
						fin_val_row = i;
						fin_val_col = j;

					}
				}
				else {
					if (total_val[i][j] < fin_val) {

						fin_val = total_val[i][j];
						fin_val_row = i;
						fin_val_col = j;

					}
				}
			}
			else continue;

		}
	}

	row = fin_val_row;
	col = fin_val_col;

	return fin_val;
}



// 要解決: 如果下的廣一點 分數就會比較多 的問題

// pre_color代表之前下的是誰 ; now_color代表下個下的是誰
// evaluate 判斷的是 pre_color 下完後 , next_color 下之前 的 value
// 可藉此判斷 pre_color 下的這步所造成的   """ 對於對方來說的整盤value """  好不好
int evaluate(Board board, char pre_color, char next_color) {

	int cell_val[ROW][COL];
	int total_val = 0;


	

	for (int i = 0; i < ROW; i++) {
		for (int j = 0; j < COL; j++) {
			cell_val[i][j] = 0;
			

			if (board.get_cell_color(i,j) == 'w') continue;		//如果空白就 = 0
			
			//自己的cell
			if (board.get_cell_color(i, j) == pre_color) {

				cell_val[i][j] += Cell_Val(board, i, j, pre_color, next_color);
			
			}

			//ene的cell
			if (board.get_cell_color(i, j) == next_color) {

				cell_val[i][j] -= Cell_Val(board, i, j, next_color, pre_color);
				//************************ene bomb negative value***************************
	
			}
			

			total_val += cell_val[i][j];
		}
	}

	return total_val;

}



bool win(Board board, char pre_color, char next_color){
	bool win = true;

	for (int i = 0; i < ROW; i++) {
		for (int j = 0; j < COL; j++) {
			if (board.get_cell_color(i, j) == pre_color || board.get_cell_color(i, j) == 'w') continue;
			else 
				return false;
		}
	}
	return true;
}

bool in_board(int i, int j) {
	if (i > ROW || i < 0 || j > COL || j < 0)
		return false;
	else return true;
}


int Cell_Val(Board board, int i, int j, char this_color, char that_color) {
	
	int cur_orb_num = board.get_orbs_num(i, j);
	int cur_cap = board.get_capacity(i, j);
	int cell_value = 0;
	//************************basic value***************************

				//爆炸範圍
	cell_value += cur_cap;
	cell_value += cur_orb_num;

	//還差多少orb可爆炸
	cell_value += 8 * cur_orb_num / cur_cap;

	//************************bomb value***************************

	//大於 or 小於 隔壁的orb數量 (可疊加)
	//上 左上 左 左下 下 右下 右 右上

	//如果小於隔壁的 那val就 - 自己的orb_num(因為會被吃掉)
	//越多比自己大的隔壁cell 就 - 越多(但越多cell 就減的越少)

	//如果必隔壁多 就 +=對方的orb_num

	if (in_board(i - 1, j)) {
		if (board.get_cell_color(i - 1, j) == that_color) {
			if (ratio_of_cell(board, i - 1, j) >= ratio_of_cell(board, i, j)) {
				cell_value -= cur_orb_num;
				cell_value -= cur_cap;
				if (critical(board, i - 1, j) && critical(board, i, j)) cell_value += ENEMY_CRITICAL_NEAR_VALUE;
			}
			else {
				cell_value += board.get_orbs_num(i - 1, j);
				cell_value += board.get_capacity(i - 1, j);
			}

		}
	}

	if (in_board(i - 1, j - 1)) {
		if (board.get_cell_color(i - 1, j - 1) == that_color) {
			if (ratio_of_cell(board, i - 1, j - 1) >= ratio_of_cell(board, i, j)) {
				cell_value -= cur_orb_num;
				cell_value -= cur_cap;
				if (critical(board, i - 1, j - 1) && critical(board, i, j)) cell_value += ENEMY_CRITICAL_NEAR_VALUE;
			}
			else {
				cell_value += board.get_orbs_num(i - 1, j - 1);
				cell_value += board.get_capacity(i - 1, j - 1);
			}
		}
	}

	if (in_board(i, j - 1)) {
		if (board.get_cell_color(i, j - 1) == that_color) {
			if (ratio_of_cell(board, i, j - 1) >= ratio_of_cell(board, i, j)) {
				cell_value -= cur_orb_num;
				cell_value -= cur_cap;
				if (critical(board, i , j - 1) && critical(board, i, j)) cell_value += ENEMY_CRITICAL_NEAR_VALUE;
			}
			else {
				cell_value += board.get_orbs_num(i, j - 1);
				cell_value += board.get_capacity(i, j - 1);
			}
		}
	}

	if (in_board(i + 1, j - 1)) {
		if (board.get_cell_color(i + 1, j - 1) == that_color) {
			if (ratio_of_cell(board, i + 1, j - 1) >= ratio_of_cell(board, i, j)) {
				cell_value -= cur_orb_num;
				cell_value -= cur_cap;
				if (critical(board, i + 1, j - 1) && critical(board, i, j)) cell_value += ENEMY_CRITICAL_NEAR_VALUE;
			}
			else {
				cell_value += board.get_orbs_num(i + 1, j - 1);
				cell_value += board.get_capacity(i + 1, j - 1);
			}
		}
	}

	if (in_board(i + 1, j)) {
		if (board.get_cell_color(i + 1, j) == that_color) {
			if (ratio_of_cell(board, i + 1, j) >= ratio_of_cell(board, i, j)) {
				cell_value -= cur_orb_num;
				cell_value -= cur_cap;
				if (critical(board, i + 1, j) && critical(board, i, j)) cell_value += ENEMY_CRITICAL_NEAR_VALUE;
			}
			else {
				cell_value += board.get_orbs_num(i + 1, j);
				cell_value += board.get_capacity(i + 1, j);
			}
		}
	}

	if (in_board(i + 1, j + 1)) {
		if (board.get_cell_color(i + 1, j + 1) == that_color) {
			if (ratio_of_cell(board, i + 1, j + 1) >= ratio_of_cell(board, i, j)) {
				cell_value -= cur_orb_num;
				cell_value -= cur_cap;
				if (critical(board, i + 1, j + 1) && critical(board, i, j)) cell_value += ENEMY_CRITICAL_NEAR_VALUE;
			}
			else {
				cell_value += board.get_orbs_num(i + 1, j + 1);
				cell_value += board.get_capacity(i + 1, j + 1);
			}
		}
	}

	if (in_board(i, j + 1)) {
		if (board.get_cell_color(i, j + 1) == that_color) {
			if (ratio_of_cell(board, i, j + 1) >= ratio_of_cell(board, i, j)) {
				cell_value -= cur_orb_num;
				cell_value -= cur_cap;
				if (critical(board, i, j + 1) && critical(board, i, j)) cell_value += ENEMY_CRITICAL_NEAR_VALUE;
			}
			else {
				cell_value += board.get_orbs_num(i, j + 1);
				cell_value += board.get_capacity(i, j + 1);
			}
		}
	}

	if (in_board(i - 1, j + 1)) {
		if (board.get_cell_color(i - 1, j + 1) == that_color) {
			if (ratio_of_cell(board, i - 1, j + 1) >= ratio_of_cell(board, i, j)) {
				cell_value -= cur_orb_num;
				cell_value -= cur_cap;
				if (critical(board, i - 1, j + 1) && critical(board, i, j)) cell_value += ENEMY_CRITICAL_NEAR_VALUE;
			}
			else {
				cell_value += board.get_orbs_num(i - 1, j + 1);
				cell_value += board.get_capacity(i - 1, j + 1);
			}
		}
	}


	//************************critical value***************************

	//如果變成可爆 value += 10

	if (critical(board, i, j)) cell_value += CRITICAL_VALUE;

	return cell_value;

}


int ratio_of_cell(Board b, int i, int j) {
	return 100 * b.get_orbs_num(i,j) / b.get_capacity(i, j);
}

bool critical(Board board, int i, int j) {
	return board.get_capacity(i, j) - board.get_orbs_num(i, j) == 1;
}

bool first_turn(Board board) {
	for (int i = 0; i < ROW; i++) {
		for (int j = 0; j < COL; j++) {
			if (board.get_cell_color(i,j) != 'w') return false;
		}
	}
	return true;
}
